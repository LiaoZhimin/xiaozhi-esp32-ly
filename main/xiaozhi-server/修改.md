

## 2025-06-04

### 1. 修改成一句话按符号分成多小句，加入到tts_queque队列中，按队列顺序处理文本和音频，唤醒词打断时清空队列。

core/utils/util.py里添加函数，用于切分句子：

```python

def text_generator(user_text)->[]:
    '''
    按多个符号拆分句子
    。！？；
    ''' 
    pattern = r'[。！？；\n]'
    text_list = re.split(pattern, user_text)
    for text in text_list:
        if text.strip():
            yield text

```

core/connection.py里添加函数，用于处理文本和音频：

```python
class ConnectionHandler:
    ...
    def ly_append_tts_queue(self, sentence):
        ''' - 将句子按符号分割，追加到队列中 '''
        self.logger.bind(tag=TAG).info(f"[{self.session_id}] ly_append_tts_queue begin: {sentence}")
        texts = text_generator(sentence)
        for text_index,segment_text in enumerate(texts):
            segment_text = get_string_no_punctuation_or_emoji(segment_text) # 去除标点符号和表情
            future = self.executor.submit(
                self.speak_and_play, segment_text, text_index
            )
            self.tts_queue.put(future)
            self.logger.bind(tag=TAG).info(f"[{self.session_id}] ly_append_tts_queue: index:{text_index} segment_text: {segment_text}")
    
    
    def ly_clear_tts_queue(self):
        ''' - 清空上一次对话的语音和文本队列 '''
        # 清除就得队列内容
        self.tts_queue.queue.clear()
        self.audio_play_queue.queue.clear()

    def ly_check_audio_finish_queue(self):
        ''' - 检查是否有文本队列未播放完成, 用于校验是否需要发送停止播放指令 '''
        return self.tts_queue.empty() and self.audio_play_queue.empty()

    def chat(self, query):
        # 清空上一次对话的语音和文本队列
        self.ly_clear_tts_queue()
        ...
        ...
```

core/connection.py里 修改 chat 函数，不需要以前的用 text_indx进行分句，直接

```python
   def chat(self, query):
        #text_index = 0
        for content in llm_responses:
            response_message.append(content)
            if self.client_abort:
                break

            # 合并当前全部文本并处理未分割部分
            full_text = "".join(response_message)
            current_text = full_text[processed_chars:]  # 从未处理的位置开始

            self.ly_append_tts_queue(content) # 将句子添加到队列中
            
            # 查找最后一个有效标点
            # punctuations = ("。", "？", "！", "；", "：")
            # last_punct_pos = -1
            # for punct in punctuations:
            #     pos = current_text.rfind(punct)
            #     if pos > last_punct_pos:
            #         last_punct_pos = pos

            # # 找到分割点则处理
            # if last_punct_pos != -1:
            #     segment_text_raw = current_text[: last_punct_pos + 1]
            #     segment_text = get_string_no_punctuation_or_emoji(segment_text_raw)
            #     if segment_text:
            #         # 强制设置空字符，测试TTS出错返回语音的健壮性
            #         # if text_index % 2 == 0:
            #         #     segment_text = " "
            #         text_index += 1
            #         self.recode_first_last_text(segment_text, text_index)
            #         future = self.executor.submit(
            #             self.speak_and_play, segment_text, text_index
            #         )
            #         self.tts_queue.put(future)
            #         processed_chars += len(segment_text_raw)  # 更新已处理字符位置

        # 处理最后剩余的文本
        full_text = "".join(response_message)
        remaining_text = full_text[processed_chars:]
        
        self.ly_append_tts_queue(remaining_text) # 将句子添加到队列中
        
        # if remaining_text:
        #     segment_text = get_string_no_punctuation_or_emoji(remaining_text)
        #     if segment_text:
        #         text_index += 1
        #         self.recode_first_last_text(segment_text, text_index)
        #         future = self.executor.submit(
        #             self.speak_and_play, segment_text, text_index
        #         )
        #         self.tts_queue.put(future)
```

core/connection.py里 修改 chat_with_function_calling 函数，不需要以前的用 text_indx进行分句

```python
    def chat_with_function_calling(self, query, tool_call=False):
        for response in llm_responses:
            。。。
            if content is not None and len(content) > 0:
                if not tool_call_flag:
                    response_message.append(content)

                    if self.client_abort:
                        self.logger.bind(tag=TAG).info(f"[{self.session_id}] client_abort,  break")
                        break

                    end_time = time.time()
                    # self.logger.bind(tag=TAG).debug(f"大模型返回时间: {end_time - start_time} 秒, 生成token={content}")

                    # 处理文本分段和TTS逻辑
                    # 合并当前全部文本并处理未分割部分
                    full_text = "".join(response_message)
                    # current_text = full_text[processed_chars:]  # 从未处理的位置开始
                    
                    self.ly_append_tts_queue(content) # 将句子添加到队列中
                    
                    # # 查找最后一个有效标点
                    # punctuations = ("。", "？", "！", "；", "：")
                    # last_punct_pos = -1
                    # for punct in punctuations:
                    #     pos = current_text.rfind(punct)
                    #     if pos > last_punct_pos:
                    #         last_punct_pos = pos

                    # # 找到分割点则处理
                    # if last_punct_pos != -1:
                    #     segment_text_raw = current_text[: last_punct_pos + 1]
                    #     segment_text = get_string_no_punctuation_or_emoji(
                    #         segment_text_raw
                    #     )
                    #     if segment_text:
                    #         text_index += 1
                    #         self.recode_first_last_text(segment_text, text_index)
                    #         future = self.executor.submit(
                    #             self.speak_and_play, segment_text, text_index
                    #         )
                    #         self.tts_queue.put(future)
                    #         # 更新已处理字符位置
                    #         processed_chars += len(segment_text_raw)
                    。。。
        # 处理function call
        if tool_call_flag and len(function_call_datas)>0:
            for function_call_data in function_call_datas:
                # self._handle_function_result(result, function_call_data, text_index + 1)
                response_message.append(result.result)
                self.ly_append_tts_queue(result.result) # 将句子添加到队列中    
        。。。
        # 处理最后剩余的文本
        full_text = "".join(response_message)
        # remaining_text = full_text[processed_chars:]
        self.logger.bind(tag=TAG).info(f"[{self.session_id}] chat_with_function_calling 处理最后剩余的文本, remaining_text: {remaining_text}")
        # if remaining_text:
        #     segment_text = get_string_no_punctuation_or_emoji(remaining_text)
        #     if segment_text:
        #         text_index += 1
        #         self.recode_first_last_text(segment_text, text_index)
        #         future = self.executor.submit(
        #             self.speak_and_play, segment_text, text_index
        #         )
        #         self.tts_queue.put(future)

```

core/handle/sendAudioHandle.py 里修改音频队列如果发送完成后，需要发送停止播放的命令，以前时用 文本的index进行判断的，现在改成按队列判断，如果 句子文本队列和音频播放队列都为空，说明已经播放完成了，需要发送停止播放的命令。

```python
async def sendAudioMessage(conn, audios, text, text_index=0):
    ...

    # 发送结束消息（如果是最后一个文本）
    # if conn.llm_finish_task and text_index == conn.tts_last_text_index:
    if conn.ly_check_audio_finish_queue():
        logger.bind(tag=TAG).info(f"[{conn.session_id}] 发送结束消息")
        await send_tts_message(conn, "stop", None)
        if conn.close_after_chat:
            await conn.close()
```


### 2. 唤醒词只播放以前的语音，需要让每次唤醒都可以去生成一次新的语音。

core/handle/helloHandle.py 里调用了llm的response_no_stream函数，因为使用了agent，需要传入session_id，所以需要修改一下，把session_id传入。

```python
async def wakeupWordsResponse(conn):
    ...
    # 末尾添加了 conn.session_id 参数
    result = conn.llm.response_no_stream(conn.config["prompt"], wakeup_word, conn.session_id)
    ...
```

在 core/providers/llm/base.py 里修改函数 response_no_stream，添加session_id参数

```python
class LLMProvider(LLMProviderBase):
    ...
    def response_no_stream(self, prompt, wakeup_word, session_id=""):
        try:
            ...
            for part in self.response(session_id, dialogue):
            ...
```


### 3. 调用agent生成的时间还是较久，

在 core/providers/llm/agent/agnet.py 里修改 用户的文本，加上 //no_thinking

```python
class LLMProvider(LLMProviderBase):
    ...
    def get_completion(self, session_id, prompts)->str:
        ...
        # 添加 no_thinking，让agent不思考， 从config.yaml中可以配置
        if not self.is_think:
            prompts += "//no_thinking"
        。。。
    ...
     def response(self, session_id, dialogue):
        try:
            ...
            ret = self.get_completion(session_id, user_input) # 修改成 user_input，以前的是last_msg
            ...
```

### 4. 使用RagFlow的Agent时，需要使用session_id

在 core/providers/llm/agent/agnet.py 里修改 获取prompt的函数，添加session_id参数

```python

```

在 connect.py 里修改，添加session_id的生成逻辑

```python


    def ly_get_session_id(self):
        ''' - 获取session_id, 会调用agent接口获取session_id '''
        if self.session_id is None or len(self.session_id) == 0:
            try:
                self.session_id = self.llm.new_session()
                self.logger.bind(tag=TAG).info(f"new connect, new session_id, agent: {self.session_id}")
            except:
                self.session_id = str(uuid.uuid4())
                self.logger.bind(tag=TAG).info(f"new connect, new session_id, uuid4: {self.session_id}")
        return self.session_id
    
    def ly_clear_session_id(self):
        ''' - 清空session_id, 会调用agent接口删除session_id'''
        try:
            self.llm.delete_session(self.session_id)
        except:
            pass
        self.session_id = ""
        self.logger.bind(tag=TAG).info(f"clear session_id: {self.session_id}")
```
